import{_ as a,c as t,a1 as o,o as s}from"./chunks/framework.nlCHK0Xf.js";const p=JSON.parse('{"title":"Scaling","description":"","frontmatter":{},"headers":[],"relativePath":"scaling.md","filePath":"scaling.md"}'),r={name:"scaling.md"};function i(n,e,l,c,h,d){return s(),t("div",null,e[0]||(e[0]=[o('<h1 id="scaling" tabindex="-1">Scaling <a class="header-anchor" href="#scaling" aria-label="Permalink to &quot;Scaling&quot;">​</a></h1><p>This page gives an overview of how the application can be scaled when the user-base grows significantly, focusing on strategies such as database optimization, load balancing, and horizontal scaling.</p><h2 id="nuxt" tabindex="-1">Nuxt <a class="header-anchor" href="#nuxt" aria-label="Permalink to &quot;Nuxt&quot;">​</a></h2><p>SSR and api-routes are scaled automatically by Cloudflare. New instances of our application are created automatically in areas, where high access rates are monitored. The code is run as near as possible at our users (&quot;on the edge&quot;), in over 400 locations worldwide:</p><p><a href="https://www.cloudflare.com/de-de/network/" target="_blank" rel="noreferrer">https://www.cloudflare.com/de-de/network/</a></p><h2 id="supabase" tabindex="-1">Supabase <a class="header-anchor" href="#supabase" aria-label="Permalink to &quot;Supabase&quot;">​</a></h2><p>The &quot;single source of truth&quot; for our data is stored in Supabase. Supabase allows to select the location, and currently this is &quot;Frankfurt am Main&quot;. To scale the application with a growing user base, there are several opportunities:</p><p>Create additional &quot;read-only instances (replicas) in areas with high access rates: most actions like clicking through profiles are &quot;read&quot; actions. Adding additional read-only nodes in areas with high access rates is easy, and takes a lot of load from the main database. Supabase allows us to do this through the Supabase-Dashboard.</p><p>For write actions it is more complicated, because concurrent actions can lead to conflicts and inconsistancy. There are advanced ways of solving these issues, but scaling for read is more than enough in the first stages of the project.</p><h2 id="caching" tabindex="-1">Caching <a class="header-anchor" href="#caching" aria-label="Permalink to &quot;Caching&quot;">​</a></h2><p>Caching data that is read often, but does not change often, is the preferred way of reducing the load on the database. Our application is run in Cloudflare Workers, and these workers allow our backend (&quot;api-routes&quot;) to store api-responses in the Cloudflare cache, so that we can response to requests with responses from the cache, instead of quering our database again. When a profile in the social network should go viral, for example in Berlin, the profile will automatically be stored in the cache in the datacenter near Berlin, and all subsequent requests will be served by the data from the cache, instead of going to the databse in Frankfurt again. This significatly improves the experience and speed for all ursers.</p><p>Depending on the case, we have to define how long a resource should be cached (for example one hour), or we can select a very long period of caching, and invalidate or update the cache, when a user (for example) is updating his/her profile.</p><h2 id="images" tabindex="-1">Images <a class="header-anchor" href="#images" aria-label="Permalink to &quot;Images&quot;">​</a></h2><p>All uploaded images are stored in the so called Supabase &quot;Bucket&quot;. Because this bucket is stored in a single location, we want to distribute it, to improve performance worldwide. For this reason, we use an &quot;image CDN&quot; (image contend delivery network). In our case, we are using the Cloudflare image CDN. Images are transformed to the size currently needed on the fly, to reduce the data that needs to be transferred. One image already transformed, is stored in the cloudflare cache, and is accessible worldwide.</p><p>This means, for a list of avatars for example, that is viewed by 100 people, we don&#39;t need to transfer each original (big) picture to each of these 100 persons. Instead, really small versions of the orgiginal pictures are created and sent around. Once these small versions are created, they are served from the cache for all subsequent requests. Bigger versions of a picture only have to be served, when a user clicks on a distinct profile.</p><p>This approch saves a lot of data and makes the whole network fast.</p><h2 id="next" tabindex="-1">Next <a class="header-anchor" href="#next" aria-label="Permalink to &quot;Next&quot;">​</a></h2><p>Read the next chapter, to learn about this documentaion.</p>',18)]))}const f=a(r,[["render",i]]);export{p as __pageData,f as default};
